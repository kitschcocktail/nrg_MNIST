# -*- coding: utf-8 -*-
"""
Created on Thu Aug 06 14:21:29 2015

@author: heiligenstein
"""

#!/usr/bin/env python
import time

try:
    import PIL.Image as Image
except ImportError:
    import Image

import numpy
import random
import theano
import theano.tensor as T
import os
import cPickle
import matplotlib.pyplot as plt
from pylab import cm


from theano.tensor.shared_randomstreams import RandomStreams

os.chdir("output_folder")

# load RBM parameters
f = cPickle.load(open('DBN.pkl','rb'))
W0     = f[0][0].get_value(borrow=True)
hbias0 = f[0][1].get_value(borrow=True)
vbias0 = f[0][2].get_value(borrow=True)

W1     = f[1][0].get_value(borrow=True)
hbias1 = f[1][1].get_value(borrow=True)
vbias1 = f[1][2].get_value(borrow=True)

W2     = f[2][0].get_value(borrow=True)
hbias2 = f[2][1].get_value(borrow=True)
vbias2 = f[2][2].get_value(borrow=True)
U      = f[2][3].get_value(borrow=True)
dbias  = f[2][4].get_value(borrow=True)

os.chdir("..")    

from logistic_sgd import load_data            
dataset = 'mnist.pkl.gz'
datasets = load_data(dataset)
test_set_x, test_set_y = datasets[2]    
    
    
def generate_MNIST(digit, numCDiters):
    """
    This script return a 10 column image of MNIST digits generated by our DBN. 
    Between samples the top-level associative memory is run for numCDiters of
    alternating Gibbs sampling between samples.
    The generative model is: lab <--> top <--> pen --> hid --> vis
    With dimensions        : 10  <--> 2000 <--> 500 --> 500 --> 784
    
    :param digit : number of the digit you want to generate 
    :digit type: int
    :param numCDiter: iterations of alternating Gibbs sampling between samples
    :param type: int
    """
    
    

    seed = numpy.zeros(10) ; seed[digit] = 1
    
    def ran_1(input_array, pc):
        """Imputes randomly scattered 1s."""
        x = int(len(input_array) * (float(pc) / 100))
        node = random.sample(xrange(0, len(input_array)), x)
        impo = numpy.array(input_array)
        for i in node:
            impo[i] = 1
        return impo
        
    # we pick a MNIST digit to sample random states in the bottom-up pass
    random.seed(1234)
    index = numpy.random.randint(test_set_y.eval().shape[0])
    data    = test_set_x.get_value(borrow=True)[index]   
    targets = seed
    

    def sigmoid(z):
        return  1 / (1 + numpy.exp(-z))
        
    def energy_vh(vlayer, vbias, hlayer, hbias, W):
        ''' Function to compute the energy of joint configuration (v, h)'''
        # e = -sumVisibleBias - sumHiddenBias - sumVisibleWeightHidden
        sum_vb = numpy.dot(vlayer, vbias)
        sum_hb = numpy.dot(hlayer, hbias)
        vWh = numpy.dot(numpy.dot(vlayer, W), hlayer)
        E = -sum_vb - sum_hb - vWh
        return E    
        
        
    def fe_v1(vlayer, vbias, hlayerprobs, hbias, W): # works
        '''Free energy, expected energy minus the entropy'''
        #f(v) = -sumVisibleBias - sumProbH(sumVisibleWeight + hbias) + entropy
        sum_vb = numpy.dot(vlayer,vbias)
        xj = numpy.dot(vlayer,W) + hbias
        B = numpy.dot(hlayerprobs,xj)
        H = sum((hlayerprobs*numpy.log(hlayerprobs)) + 
            ((1 - hlayerprobs)*numpy.log(1 - hlayerprobs)))
        FE1 = - sum_vb - B + H
        return FE1
        
        
    def MSE(imageA, imageB):
        err = numpy.sum((imageA.astype("float") - imageB.astype("float")) ** 2)
        err /= float(imageA.shape[0])
        return err
    
    def MAE(imageA, imageB):
        err = numpy.sum(numpy.abs(imageA.astype("float") - imageB.astype("float")))
        err /= float(imageA.shape[0])
        return err
    

        
    # Perform a bottom-up pass to get wake/positive phase probabilites 
    # and sample states
    def up(digit_image):
        wakehidprobs   = sigmoid(numpy.dot(digit_image,W0) + hbias0)
        wakehidstates  = (wakehidprobs > numpy.random.rand(1, 500)).astype(float)[0]
        e0             = energy_vh(digit_image, vbias0, wakehidstates, hbias0, W0)
        fe0            = fe_v1(digit_image, vbias0, wakehidprobs, hbias0, W0)
        wakepenprobs   = sigmoid(numpy.dot(wakehidstates,W1) + hbias1)
        wakepenstates  = (wakepenprobs > numpy.random.rand(1, 500)).astype(float)[0]
        e1             = energy_vh(wakehidstates, vbias1, wakepenstates, hbias1, W1)
        fe1            = fe_v1(wakehidstates, vbias1, wakepenprobs, hbias1, W1)
        waketopprobs   = sigmoid(numpy.dot(wakepenstates,W2) + hbias2)
        waketopstates  = (waketopprobs > numpy.random.rand(1,2000)).astype(float)[0]
        e2             = energy_vh(wakepenstates, vbias2, waketopstates, hbias2, W2)
        fe2            = fe_v1(wakepenstates, vbias2, waketopprobs, hbias2, W2)
        
        clayerstates = (numpy.dot(waketopstates, U.T) + dbias) / 100
        e_class = energy_vh(clayerstates, dbias, waketopstates, hbias2, U)
        fe_class = fe_v1(clayerstates, dbias, waketopprobs, hbias2, U)
        classified_as = numpy.where(clayerstates == numpy.amax(clayerstates))
        
        E = e0 + e1 + e2 + e_class
        FE = fe0 + fe1 + fe2 + fe_class
        
        return waketopstates, classified_as, E, FE
    

    # Perform numCDiters Gibbs Sampling iterations using the top level
    # undirected associative memory
    def down(up_states, class_label, before=True):
        
        visprob = []
        Es = [] ; FEs = []
        negtopstates = waketopstates[0]
        
        if before:
            for imp_pc in range(0, 10): # see if noise before of after CD
                negtopstates = ran_1(negtopstates, imp_pc)
                for k in range(numCDiters):
                    negpenprobs  = sigmoid(numpy.dot(negtopstates,W2.T) + vbias2)
                    negpenstates = (negpenprobs > numpy.random.rand(1,500)).astype(float)[0]
                    neglabprobs  = class_label # label clamped
                    negtopprobs  = sigmoid(numpy.dot(negpenstates,W2) + numpy.dot(neglabprobs,U) + hbias2)
                    negtopstates = (negtopprobs > numpy.random.rand(1,2000)).astype(float)[0]
    
                sleeppenstates = negpenstates
                sleephidprobs = sigmoid(numpy.dot(sleeppenstates,W1.T) + vbias1)
                sleephidstates = (sleephidprobs > numpy.random.rand(1,500)).astype(float)[0]
                e1 = energy_vh(sleeppenstates, hbias1, sleephidstates, vbias1, W1.T)      
                fe1 = fe_v1(sleeppenstates, hbias1, sleephidprobs, vbias1, W1.T)
                impvisprobs  = sigmoid(numpy.dot(sleephidstates,W0.T) + vbias0)
                visprob.append(impvisprobs)
                Es.append(e1)
                FEs.append(fe1)
            

        else:
            for k in range(numCDiters):
                negpenprobs  = sigmoid(numpy.dot(negtopstates,W2.T) + vbias2)
                negpenstates = (negpenprobs > numpy.random.rand(1,500)).astype(float)[0]
                neglabprobs  = class_label # label clamped
                negtopprobs  = sigmoid(numpy.dot(negpenstates,W2) + numpy.dot(neglabprobs,U) + hbias2)
                negtopstates = (negtopprobs > numpy.random.rand(1,2000)).astype(float)[0]
            for imp_pc in range(0, 10): # see if noise before of after CD
                impnegpenstates = ran_1(negpenstates, imp_pc)
                sleeppenstates = impnegpenstates
                sleephidprobs = sigmoid(numpy.dot(sleeppenstates,W1.T) + vbias1)
                sleephidstates = (sleephidprobs > numpy.random.rand(1,500)).astype(float)[0]
                e1 = energy_vh(sleeppenstates, hbias1, sleephidstates, vbias1, W1.T)      
                fe1 = fe_v1(sleeppenstates, hbias1, sleephidprobs, vbias1, W1.T)
                impvisprobs  = sigmoid(numpy.dot(sleephidstates,W0.T) + vbias0)
                visprob.append(impvisprobs)
                Es.append(e1)
                FEs.append(fe1)
        
        return visprob, Es, FEs
    
    waketopstates, class_up, E_up, FE_up = up(data)
    visprob, E_down, FE_down = down(waketopstates, targets, before=True)
    waketopstates2, class_up2, E_up2, FE_up2 = up()
    

    '''
    # plot results        
    fig, axes = plt.subplots(1, 10, figsize=(10, 1),
                             subplot_kw={'xticks': [], 'yticks': []})
        
    fig.subplots_adjust(hspace=0.0, wspace=0.0)    

    index = 0
    for ax, output in zip(axes.flat, visprob):
        ax.imshow(-output.reshape(28,28), cmap=cm.gray)
        title = round(MSE(visprob[0], output), 4)
        subtitle = round(Es[index], 2)
        ax.set_title(str(title) + '\n' + str(subtitle))
        index += 1
    #plt.plot(Es)
    plt.show()
    
    #fig.show()
    os.chdir('test_results')
    fig.savefig('gen', bbox_inches='tight')
    os.chdir('..')'''
    
    MSEs = numpy.array([MSE(visprob[0], gen) for gen in visprob])
    MAEs = numpy.array([MAE(visprob[0], gen) for gen in visprob])
    
    return Es, FEs, MSEs, MAEs


    

CDiters = 500
Es_stack = []
FEs_stack = []
MSEs_stack = []
MAEs_stack = []
for i in range(100):
    digit = numpy.random.randint(0,10)
    Es, FEs, MSEs, MAEs = generate_MNIST(digit, CDiters)
    print 'generating data for iteration', i
    Es_stack.append(Es)
    FEs_stack.append(FEs)
    MSEs_stack.append(MSEs)
    MAEs_stack.append(MAEs)

Es_stack = numpy.array(Es_stack)
FEs_stack = numpy.array(FEs_stack)
MSEs_stack = numpy.array(MSEs_stack)
MAEs_stack = numpy.array(MAEs_stack)

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(8, 16))
ax1.boxplot(Es_stack)
ax1.set_title('energies by % of imputation')
ax1.set_ylabel('energy')
ax1.xaxis.set_ticklabels([])
ax2.boxplot(FEs_stack)
ax2.set_ylabel('free energy')
ax2.xaxis.set_ticklabels([])
ax3.set_title('errors')
ax3.boxplot(MSEs_stack)
ax3.set_ylabel('MSE')
ax3.xaxis.set_ticklabels([])
ax4.boxplot(MAEs_stack)
ax4.set_ylabel('MAE')
ax4.xaxis.set_ticklabels(range(0, 10))
fig.savefig('gen_errs_before', bbox_inches='tight')

